name: Test Environment Secrets

on:
  push:
    branches:
      - main # Run on push to main branch
  workflow_dispatch: # Also allow manual triggering

jobs:
  test-secrets:
    name: Test Environment Secrets
    runs-on: ubuntu-latest
    environment: production # This is important - use the environment where you set secrets

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Create temporary files from secrets
        run: |
          # Create files from the secrets
          echo "${{ secrets.POSTGRES__SECRET_ENV_FILE }}" > postgres_env.txt
          echo "${{ secrets.PAYLOAD__SECRET_ENV_FILE }}" > payload_env.txt

          # Show that files exist and their line count
          echo "PostgreSQL env file line count: $(wc -l < postgres_env.txt)"
          echo "Payload CMS env file line count: $(wc -l < payload_env.txt)"

          # Print file contents with masked sensitive values
          echo "===== PostgreSQL Environment Variables ====="
          grep -v "PASSWORD\|SECRET" postgres_env.txt || echo "No non-sensitive data to display"
          echo "[Password and secret values are masked for security]"

          echo "===== Payload CMS Environment Variables ====="
          grep -v "PASSWORD\|SECRET\|URI" payload_env.txt || echo "No non-sensitive data to display"
          echo "[Password, database URI, and secret values are masked for security]"

          # Test if env vars can be loaded and used
          echo "===== Testing Environment Variable Loading ====="
          export $(grep -v "PASSWORD\|SECRET" postgres_env.txt | xargs)
          echo "PostgreSQL database name: $POSTGRES_DB"
          echo "PostgreSQL username: $POSTGRES_USER"

      - name: Clean up temporary files
        run: |
          rm -f postgres_env.txt payload_env.txt
